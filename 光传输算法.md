# 光传输概述

积分器作用：采用蒙特卡罗数值积分技术求解渲染方程（光传输方程）。

接口:

```c++
/* scene为场景指针，用来查询光源、几何体信息；
 ray为入射光线
 sample 为沿此光线生成的一个采样
 alpha是输出变量，返回表面透明度
 返回值为ray的辐射亮度
*/
    Color Li(Scene*, Ray&, Sample*,float* alpha);

// 生成采样
    void RequestSamples(Sample*, Scene*);
```

> 积分器分为表面散射和体积散射两种

## 表面散射
表面散射积分器 实现的函数和接口积分器类相同。


### 直接光照积分器
即只考虑由光源直接照射的情况，忽略间接光照。

直接光照的积分方程：

$$L_o(p,\omega_o) = \int f_r(p,\omega_o,\omega_i) L_d(p,\omega_i) |cos\theta_i| d\omega_i$$


#### 一、 光源选择
先考虑一个小问题，对于多光源场景，如何选择直接光照中的Ld项？

有两种无偏策略：
- 遍历所有光源，对每个光源都进行采样，对结果进行累加；

由于
$$L_d(p,w_i) = \Sigma_{j=1}^{nLights} L_{d_j}(p,w_i)$$

故
$$L_o(p,\omega_o) = \int f_r(p,\omega_o,\omega_i) L_d(p,\omega_i) |cos\theta_i| d\omega_i = \Sigma_{j=1}^{nLights} \int f(p,w_o,w_i) L_{d_{j}}(p,w_i)|cos\theta_i| dw_i $$

- 随机选择一个光源，只对该光源进行采样，再乘以光源个数作为结果。

这种策略的正确性利用了期望的线性性质。

RequestSamples的两种实现：

```c++
// sample_all_lights
1. for every light, generate light sample and bsdf sample.

// sample_one_light
1. generate 1D sample, used as light index
2. do sample in this light.    
```


Li 的两种实现（Li函数计算某条光线在交点处的direct lighting radiance）

```c++
// sample all lights

/*
    res = Color(0);
    for light : lights:
        res += Ld
    // 这里每个光源生成nSamples个采样，所以res 每次加上一个采样/nSamples作为最终的贡献
*/
    void sampleAllLights(Point&p,Normal& n, Vec3& wo, Vec3* wi, BSDF* bsdf,Sample* sample) {
        Color L(0,0,0);
        
        for(int i=0;i<nLights;i++) {
            Light* light = lights[i];
            int lightSamples = light->nSamples;

            Color Ld(0,0,0);
            for(int i=0;i<nSamples;i++) {
                Ld += estimateDirectLighting();
                L += Ld/nSamples;
            }   
        }
    }
```

```c++
    void sampleOneLights(Point&p,Normal& n, Vec3& wo, Vec3* wi, BSDF* bsdf,Sample* sample) {
         Light* light = lights[lightOffset]; // lightOffset是随机生成的下标

        return nLights * estimateDirectLighting();
    }
```


