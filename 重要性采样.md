# 重要性采样

重要性采样是减小方差的计数。

对monte carlo estimator $$F_N = \frac{1}{N} \Sigma_{i=1}^N f(x)/ p(x)$$ 而言，Xi 的分布密度函数 p\(x\)   和 f\(x\) 越接近， 其收敛速度就越快。

因此，我们将采样更多的集中在f\(x\) 较大的地方，可以更有效率。

一般而言，根据BSDF或者入射光分布等进行方向采样，比uniform的方式效率要高。

图形学中的积分，一般被积函数f 是多个函数的乘积，要找到和整个乘积相似的p是比较困难的，然而找出与其中一项或者某几项相似的p是相对容易的，光传输算法中，估算的积分是光照、可见性、散射、余弦项的乘积。

# 多维重要性采样

就是说被积函数f 是多个函数的乘积，如何选择p分布使得它和乘积后的结果更相似。

考虑直接照明的积分：

$$L_o(p,\omega_o) = \int f_r(p,\omega_o,\omega_i) L_d(p,\omega_i) |cos\theta_i| d\omega_i$$

若基于$$f_r 或 L_d$$ 的分布进行采样，则另一个的分布采样性能会很差。

比如，对于镜面反射的BSDF，仅在镜面方向为中心很小的范围内采样有贡献， 此时若对$$L_d$$进行采样，则大部分采样的贡献都为0，因此这种情况下，BSDF采样会更好；反过来，对于接近漫反射的BSDF而言，对光源采样更好（方差更小）。

## MIS（多重重要性采样）

对于多维采样：$$\int f(x) g(x) dx$$

MIS下的monte carlo estimator为：

$$\frac{1}{N_f} \Sigma_{i=1}^{N_f} \frac{f(X)g(X) w_f(X)}{p_f(X} + \frac{1}{N_g} \Sigma_{i=1}^{N_g} \frac{f(X)g(X) w_g(X)}{p_g(X}$$

即从和f函数更匹配的$$p_f$$中进行Nf个采样，在和g更匹配的pg中进行Ng个采样，其中wf和wg是加权函数。

### 加权函数w

一般采用 balance heuristic 作为加权函数。

$$w_s(x) = \frac{N_s p_s(x) }{\Sigma_k N_k p_k(x)}$$

比如上面的例子中

$$w_f(x) = \frac{N_f p_f(x)} {N_f p_f(x) + N_g p_g(x)}$$

进一步，w可以选择幂函数启发函数，可以进一步减小方差。

$$w_s(x） = \frac{ (N_s p_s(x))^\beta }{\Sigma_k (N_k p_k(x))^\beta }$$

## 重要性采样的应用

### 对反射函数采样

> f 函数就是BSDF函数，因此选择和BSDF类似的p进行采样。

```c++
    Color BxDF::Sample_f(const Vec3& wo, Vec3* wi, float* pdf) const {
        *wi = cosSampleHemisphere();    // 按照余弦加权进行重要性采样

    // wi 和 wo 在同一侧，pdf等于$cos\theta / \pi$
        *pdf = (wi->z * wo.z > 0) ? abs(wi->z) * INV_PI : 0;
    }
```

#### Blinn 微面元采样
对于微面元模型，一般选择p为类似BSDF中的D项（法线分布函数）（即对D进行采样）

Blinn模型的NDF：
$$D(cos\theta_h) = (n+2) (cos\theta_h)^n$$

这里选择的p函数为：（归一化因子和上面的D有所不同）
$$p_h (cos\theta_h) = (n+1) cos^n\theta_h$$

$$p_h(cos\theta_h) = p_h(\theta) p_h(\phi)$$

$$p_h(\phi) = 1/2\pi$$

$$cos\theta_h = n+1\sqrt{\xi_1}, \phi = 2\pi \xi_2$$

因此，根据上式可以对wh进行采样，根据几何关系可以得到wi的方向。

PDF的计算如下：
1. wh的pdf如上面所示，$$p_h(cos\theta) = (n+1) cos^\theta_h$$
2. wh的pdf和wi的pdf的关系如下：
由pbrt 13.5 的公式：

$$p_i = |\frac{d\omega_h}{\omega_i}| p_h$$

$$\frac{dwh}{dwi} = \frac{sin\theta_h d\theta_h d\phi_h}{sin\theta_i d\theta_i d\phi_i} = \frac{sin\theta_h d\theta_h d\phi_h}{sin2\theta_h 2d\theta_h \phi_h}= \frac{1}{2 * 2 * cos\theta_h} = \frac{1}{cos\theta_h}$$


```c++
    void Blinn::Sample_f(const Vec3& wo, Vec3* wi,float *pdf) {
//    下面四行首先对cos\theta 以及phi进行采样，然后得到方向wh
        float cosTheta = pow(random1,1/(n+1));
        float sinTheta = 1 - cosTheta*cosTheta;
        float phi = 2 * PI * random2;
        Vec3 wh = ShpereDirection(cosTheta,sinTheta,phi);

// 根据wh和wo，计算wi
        * wi = -wo + 2 * wh * Dot(wh,wo);

// 计算wh的pdf
        float tmp = (n + 1) * pow(cosTheta,n);  // 上面的p_h(cos\theta)

// 根据wh的pdf，得到wi的pdf
        *pdf = tmp/ (2*PI * 4 * Dot(wo,wh))
    }
```









